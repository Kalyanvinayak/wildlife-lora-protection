# backend/main.py

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import firebase_admin
from firebase_admin import credentials, firestore
import os
from datetime import datetime
from ml_model import train_or_load_model, predict_anomaly # Import ML functions

# --- Firebase Initialization ---
# Path to your Firebase service account key
FIREBASE_CONFIG_PATH = os.path.join(os.path.dirname(__file__), 'firebase_config.json')

try:
    cred = credentials.Certificate(FIREBASE_CONFIG_PATH)
    firebase_admin.initialize_app(cred)
    db = firestore.client()
    print("Firebase initialized successfully.")
except Exception as e:
    print(f"Error initializing Firebase: {e}")
    print("Please ensure 'firebase_config.json' is correctly placed and contains valid credentials.")
    # Exit or handle error appropriately if Firebase is critical
    exit(1)

app = FastAPI(
    title="Cross-Border Wildlife & Community Protection System Backend",
    description="API for sensor data ingestion, alert management, and dashboard data.",
    version="1.0.0"
)

# --- ML Model Initialization ---
# Load or train the ML model on startup
# In a real application, you might load a pre-trained model or train periodically
ml_model = train_or_load_model()

# --- Pydantic Models for Request/Response ---

class SensorData(BaseModel):
    """
    Represents sensor data received from a LoRa node.
    """
    node_id: str
    node_type: str # e.g., "collar", "weather_station", "motion_detector"
    latitude: float
    longitude: float
    temperature: float
    humidity: float
    gas_level: float = None # Optional, for gas sensors
    battery_voltage: float # Node battery level
    timestamp: str = None # ISO format string, will be set by server if not provided

class Alert(BaseModel):
    """
    Represents an alert generated by the system.
    """
    alert_type: str # e.g., "intrusion", "animal_movement", "flood", "fire"
    node_id: str
    latitude: float
    longitude: float
    severity: str # e.g., "low", "medium", "high", "critical"
    message: str
    timestamp: str = None # ISO format string, will be set by server if not provided

class Command(BaseModel):
    """
    Represents a command to be sent to a local device (e.g., siren/LED).
    """
    device_id: str # ID of the villager alert device
    command_type: str # e.g., "activate_siren", "deactivate_siren", "display_message"
    message: str = None # Message for LED display
    duration_seconds: int = None # For siren activation

# --- API Endpoints ---

@app.get("/")
async def read_root():
    """
    Root endpoint for basic API health check.
    """
    return {"message": "Welcome to the Cross-Border Protection System API!"}

@app.post("/sensor_data/")
async def receive_sensor_data(data: SensorData):
    """
    Receives sensor data from LoRa gateways.
    Stores data in Firestore and performs anomaly detection.
    """
    try:
        # Set server-side timestamp if not provided by node
        if not data.timestamp:
            data.timestamp = datetime.utcnow().isoformat() + "Z" # UTC with Z for Zulu time

        # Convert to dictionary for Firestore
        data_dict = data.model_dump()

        # Perform ML anomaly detection
        anomaly_score = predict_anomaly(ml_model, data_dict)
        data_dict['is_anomaly'] = (anomaly_score == -1) # True if outlier, False if inlier

        # Store in Firestore
        doc_ref = db.collection("sensor_data").add(data_dict)
        print(f"Received data from Node {data.node_id}, stored as {doc_ref[1].id}. Anomaly: {data_dict['is_anomaly']}")

        # If anomaly detected, generate an alert
        if data_dict['is_anomaly']:
            alert_message = f"Potential anomaly detected from {data.node_type} node {data.node_id} at Lat: {data.latitude}, Lon: {data.longitude}. Check data."
            await generate_alert(Alert(
                alert_type="anomaly_detection",
                node_id=data.node_id,
                latitude=data.latitude,
                longitude=data.longitude,
                severity="medium",
                message=alert_message
            ))

        return {"status": "success", "message": "Sensor data received and processed", "doc_id": doc_ref[1].id}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to process sensor data: {e}")

@app.post("/alerts/")
async def generate_alert(alert: Alert):
    """
    Generates a new alert.
    Stores alert in Firestore and can trigger external notifications (e.g., to villagers).
    """
    try:
        if not alert.timestamp:
            alert.timestamp = datetime.utcnow().isoformat() + "Z"

        alert_dict = alert.model_dump()
        doc_ref = db.collection("alerts").add(alert_dict)
        print(f"Alert generated: {alert.alert_type} from {alert.node_id}. Stored as {doc_ref[1].id}")

        # --- Logic to trigger local devices (sirens/LEDs) ---
        # This is a simplified example. In a real system, you'd have a more robust
        # mechanism to map alerts to specific local devices and send commands.
        # For demonstration, let's assume a "critical" alert triggers a siren.
        if alert.severity == "critical" or alert.alert_type in ["flood", "fire", "intrusion"]:
            # This would typically involve sending a command to a specific gateway
            # or directly to a device if it has its own internet connection.
            # For this setup, we'll store it as a pending command in Firestore
            # for the villager alert device to pick up.
            command_message = f"ALERT: {alert.alert_type.upper()}! {alert.message}"
            command_data = Command(
                device_id="villager_device_001", # Example device ID
                command_type="activate_siren" if alert.alert_type in ["flood", "fire", "intrusion"] else "display_message",
                message=command_message,
                duration_seconds=30 # Siren for 30 seconds
            ).model_dump()
            # Store command in a 'commands' collection, perhaps under a specific device ID
            db.collection("commands").document("villager_device_001").set(command_data, merge=True)
            print(f"Command issued for villager_device_001: {command_data['command_type']}")


        return {"status": "success", "message": "Alert generated", "doc_id": doc_ref[1].id}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to generate alert: {e}")

@app.get("/sensor_data_history/")
async def get_sensor_data_history(node_id: str = None, limit: int = 100):
    """
    Fetches historical sensor data.
    Optionally filter by node_id.
    """
    try:
        query = db.collection("sensor_data").order_by("timestamp", direction=firestore.Query.DESCENDING).limit(limit)
        if node_id:
            query = query.where("node_id", "==", node_id)

        docs = query.get()
        data = [doc.to_dict() for doc in docs]
        return {"status": "success", "data": data}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch sensor data history: {e}")

@app.get("/alerts_history/")
async def get_alerts_history(alert_type: str = None, severity: str = None, limit: int = 100):
    """
    Fetches historical alerts.
    Optionally filter by alert_type or severity.
    """
    try:
        query = db.collection("alerts").order_by("timestamp", direction=firestore.Query.DESCENDING).limit(limit)
        if alert_type:
            query = query.where("alert_type", "==", alert_type)
        if severity:
            query = query.where("severity", "==", severity)

        docs = query.get()
        data = [doc.to_dict() for doc in docs]
        return {"status": "success", "data": data}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch alerts history: {e}")

@app.get("/commands/{device_id}")
async def get_device_commands(device_id: str):
    """
    Fetches pending commands for a specific local device.
    This endpoint would be polled by the villager alert device.
    """
    try:
        doc_ref = db.collection("commands").document(device_id)
        doc = doc_ref.get()
        if doc.exists:
            command_data = doc.to_dict()
            # Optionally, clear the command after fetching if it's a one-time command
            # db.collection("commands").document(device_id).delete()
            return {"status": "success", "command": command_data}
        else:
            return {"status": "no_command", "message": f"No pending commands for device {device_id}"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch commands: {e}")

@app.post("/commands/clear/{device_id}")
async def clear_device_commands(device_id: str):
    """
    Clears pending commands for a specific local device after it has processed them.
    """
    try:
        db.collection("commands").document(device_id).delete()
        return {"status": "success", "message": f"Commands cleared for device {device_id}"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to clear commands: {e}")